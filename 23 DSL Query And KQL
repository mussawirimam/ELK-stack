Tip: if you type in kql in the kibana discover search, at the backend it convert and run a DSL. To check that, you will have to click on INSPECT after KQL is searched > click on REQUEST to see the DSL
Tip2: if you do GET my_class/_search ----> it will give you all the documents within the my_class index
and starting after you can create advanced query by adding parameters within the body of the json to fine tune the query search to match the exact document or field you are looking for.
e.x:
GET my_class/_search
{
parameters
parameters
parameters 
etc
}

Tip3: if you want to add timestamp/date to any of your document for the testing purpose. You can copy that from any of your document, and look for the timestamp field from your json payload of your document and copy it from there. 
POST _bulk
{ "index": { "_index": "my_class" } }
{ "name": "Chintaman", "date": "2025-04-09T14:37:19.666Z", "age": 31, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }

GET my_class/_search

NOTE: 
querytypes: term, terms, and match queries
DATATYPES: keyword and text

PURPOSE:
------------
term: single-value search 
terms: mutliple single value search
term or terms is specific KEYWORD DATATYPE based search 
------------
match: general purpose multi-value search
match is general tokenized TEXT DATATYPE based search
------------

we also can do filter, aggregation, sorting, and range based searches to filter the search more etc
-------------------------------------------------------------------------
DSL:
-------------------------------------------------------------------------
DELETE my_class
### instead of delete you should do the reindex command
PUT my_class
{
  "mappings": {
    "properties": {
      "name": { "type": "keyword" },
      "age": { "type": "integer" },
      "grade": { "type": "keyword" },
      "subjects": { "type": "keyword" },
      "score": { "type": "float" },
      "joined_date": { "type": "date" }
    }
  }
}
GET my_class/_mapping

### we can send upto 3000 records in single bulk request
POST _bulk
{ "index": { "_index": "my_class" } }
{ "name": "Chintaman", "date": "2025-04-09T14:37:19.666Z", "age": 31, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }
{ "index": { "_index": "my_class" } }
{ "name": "Mohan", "date": "2025-04-07T14:37:19.666Z", "age": 31, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }

POST _bulk
{ "index": { "_index": "my_class" } }
{ "name": "Mohan", "date": "2025-04-08T14:37:19.666Z", "age": 31, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }


GET my_class/_search

GET my_class/_search
{
  "query": {
  "match_all": {}  
  }
}

### for matching on specific field but generalized
GET my_class/_search
{
  "query": {
    "match": {
      "name": "Chintaman"
    }
  }
}

### term to find single value
GET my_class/_search
{
  "query": {
    "term": {
      "name": {
        "value": "Chintaman"
      }
    }
  }
}
or 
GET my_class/_search
{
  "query": {
    "term": {
      "name.keyword": { #### <-------------- if KEYWORD is mapped with the name as a DATATYPE
        "value": "Chintaman"
      }
    }
  }
}


### terms to find multiple values
GET my_class/_search
{
  "query": {
    "terms": {
      "name": [
        "Chintaman",
        "Mohan"
      ]
    }
  }
}

### range
POST _bulk
{ "index": { "_index": "my_class" } }
{ "name": "Sravanan", "date": "2025-04-08T14:37:19.666Z", "age": 35, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }
{ "index": { "_index": "my_class" } }
{ "name": "Rathore", "date": "2025-04-06T14:37:19.666Z", "age": 45, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }

GET my_class/_search
{
  "query": {
    "range": {
      "age": {
        "gte": 40,
        "lte": 50
      }
    }
  }
}

### range with timestamp/date if its timestamp instead of date field, you will add @timestamp instead of date in field
### tip: I had to change 2026 and month in the records because I couldnt find record for 2025..
POST _bulk
{ "index": { "_index": "my_class" } }
{ "name": "Mussa", "date": "2026-01-02T14:37:19.666Z", "age": 35, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }
{ "index": { "_index": "my_class" } }
{ "name": "Sirish", "date": "2026-01-01T14:37:19.666Z", "age": 45, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }

GET my_class/_search
{
  "query": {
    "range": {
      "date": {
        "gte": "now-30d",
        "lt": "now"
      }
    }
  }
}
or
# you can as well add the timestamp to fetch the records within the greater then and less then or you can do it with relatable as shown above or with 24 hours etc
GET my_class/_search
{
  "query": {
    "range": {
      "date": {
        "gte": "2026-01-01T14:37:19.666Z",
        "lt": "2026-02-01T14:37:19.666Z"
      }
    }
  }
}

### if you are adding filter query match on top of the range, you will have ot use the bool query as in addition to it. So there are three pieces to the code now.
# 1: bool, 2: must, 3: your filters (range and match or term)
### Great — this is where you use a bool query.
In Elasticsearch, whenever you want to combine multiple queries (range + match + term, etc.), you wrap them inside bool.
Your current query has only a range. To add a match condition, you do this:
✅ Range + Match together (most common pattern)
### with match and range
GET my_class/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "range": {
            "date": {
              "gte": "now-30d",
              "lt": "now"
            }
          }
        },
        {
          "match": {
            "name": "Mussa"
          }
        }
      ]
    }
  }
}
### with term and range
GET my_class/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "range": {
            "date": {
              "gte": "now-30d",
              "lt": "now"
            }
          }
        },
        {
          "term": {
            "name": {
              "value": "Mussa"
            }
          }
        }
      ]
    }
  }
}

GET my_class/_search
### inline
{ "query": { "bool": { "filter": [ { "term": { "grade": "A" } }, { "range": { "age": { "gte": 40 } } } ] } } }
or pretty formatted
GET my_class/_search
{
  "query": {
    "bool": {
      "filter": [
        {
          "term": {
            "grade": "A"
          }
        },
        {
          "range": {
            "age": {
              "gte": 40
            }
          }
        }
      ]
    }
  }
}

### applying multiple 3 filters: adding bool, term, range of age, and rage of date
GET my_class/_search
{
  "query": {
    "bool": {
      "must": [
        {
          "term": {
            "grade": "A"
          }
        },
        {
          "range": {
            "age": {
              "gte": 40
            }
          }
        },
        {
          "range": {
            "date": {
              "gte": "now-90d",
              "lte": "now"
            }
          }
        }
      ]
    }
  }
}

Bool also has should beside must
----------------------------------------------
AGGREGATIONS:
----------------------------------------------
When working with databases, you can use the GROUP BY clause in MSSQL. It summarizes data based on the values of one or more columns.
e.g:
SELECT COUNT(*) AS total, name
FROM students
WHERE date > GETDATE()
GROUP BY name
ORDER BY name DESC;




-------------------------------------------------------------------------
DSL QUERY.docx
-------------------------------------------------------------------------
Elasticsearch DSL Tutorial with Examples
1️⃣ Introduction to DSL
Elastic search DSL is a powerful query language based on JSON used to search, filter, and analyze data in Elasticsearch.
A typical search query looks like this:
GET my-index/_search
{
  "query": {
    "match": {
      "field_name": "value"
    }
  }
}
 
2️⃣ Sample Data to Ingest
Create an index called students and ingest the following documents:
Create Index:
PUT students
{
  "mappings": {
    "properties": {
      "name": { "type": "text" },
      "age": { "type": "integer" },
      "grade": { "type": "keyword" },
      "subjects": { "type": "keyword" },
      "score": { "type": "float" },
      "joined_date": { "type": "date" }
    }
  }
}
### in this name is both text and keyword as how the mapping of the name should be
PUT students
{
  "mappings": {
    "properties": {
      "name": {
        "type": "text",
        "fields": {
          "keyword": {
            "type": "keyword"
          }
        }
      },
      "age": { "type": "integer" },
      "grade": { "type": "keyword" },
      "subjects": { "type": "keyword" },
      "score": { "type": "float" },
      "joined_date": { "type": "date" }
    }
  }
}

### to get the mapping 
GET my_class/_mapping
### If you only want to check one field (example: joined_date)
GET my_class/_mapping/field/joined_date
### Or multiple fields:
GET my_class/_mapping/field/name,age,grade
### To confirm the index exists
GET _cat/indices/my_class?v


Bulk Insert Sample Data:
POST _bulk
{ "index": { "_index": "students" } }
{ "name": "Alice", "age": 20, "grade": "A", "subjects": ["Math", "English"], "score": 85.5, "joined_date": "2023-01-15" }
{ "index": { "_index": "students" } }
{ "name": "Bob", "age": 22, "grade": "B", "subjects": ["Science", "English"], "score": 78.0, "joined_date": "2023-03-12" }
{ "index": { "_index": "students" } }
{ "name": "Charlie", "age": 21, "grade": "C", "subjects": ["Math", "History"], "score": 65.3, "joined_date": "2023-06-10" }
{ "index": { "_index": "students" } }
{ "name": "Diana", "age": 23, "grade": "A", "subjects": ["Science", "Math"], "score": 92.0, "joined_date": "2023-02-05" }
{ "index": { "_index": "students" } }
{ "name": "Ethan", "age": 20, "grade": "B", "subjects": ["History", "English"], "score": 72.4, "joined_date": "2023-05-18" }
 
3️⃣ Basic Queries
Match Query (Full-text search):
json
CopyEdit
GET students/_search
{
  "query": {
    "match": {
      "name": "Alice"
    }
  }
}
Term Query (Exact match for keyword fields):
json
CopyEdit
GET students/_search
{
  "query": {
    "term": {
      "grade": "A"
    }
  }
}
 
4️⃣ Filtered Queries and Compound Queries
Range Query (Filter by score):
json
CopyEdit
GET students/_search
{
  "query": {
    "range": {
      "score": {
        "gte": 80
      }
    }
  }
}
Bool Query (Combine multiple conditions):
json
CopyEdit
GET students/_search
{
  "query": {
    "bool": {
      "must": [
        { "term": { "grade": "A" } },
        { "range": { "score": { "gte": 85 } } }
      ]
    }
  }
}
 
5️⃣ Aggregations
Average Score:
GET students/_search
{
  "size": 0,
  "aggs": {
    "average_score": {
      "avg": {
        "field": "score"
      }
    }
  }
}
Students Count by Grade:
json
CopyEdit
GET students/_search
{
  "size": 0,
  "aggs": {
    "grades_count": {
      "terms": {
        "field": "grade"
      }
    }
  }
}
 
6️⃣ Sorting and Pagination
Sort by Score Descending:
json
CopyEdit
GET students/_search
{
  "sort": [
    { "score": "desc" }
  ]
}
Pagination with from and size:
json
CopyEdit
GET students/_search
{
  "from": 0,
  "size": 2
}
 
7️⃣ Real-World Use Cases
•	Filter top performers: score >= 90
•	Count how many students chose "Math"
•	Average score per subject (use nested fields if subject scores are stored separately)
•	Students who joined after a certain date

